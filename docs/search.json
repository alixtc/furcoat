[
  {
    "objectID": "reference/has_no_infs.html",
    "href": "reference/has_no_infs.html",
    "title": "has_no_infs",
    "section": "",
    "text": "checks.has_no_infs(data, columns=None)\nCheck if a DataFrame has any infinite (inf) values.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe input DataFrame to check for null values.\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for null value check. By default, all columns are checked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"a\": [1, 2],\n...         \"b\": [1.0, float(\"inf\")],\n...     }\n... )\n&gt;&gt;&gt; plg.has_no_infs(df)\nTraceback (most recent call last):\n  ...\npelage.checks.PolarsAssertError: Details\nshape: (1, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ f64 │\n╞═════╪═════╡\n│ 2   ┆ inf │\n└─────┴─────┘\nError with the DataFrame passed to the check function:\n--&gt;\n&gt;&gt;&gt; plg.has_no_infs(df, [\"a\"])  # or  plg.has_no_infs(df, \"a\")\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ f64 │\n╞═════╪═════╡\n│ 1   ┆ 1.0 │\n│ 2   ┆ inf │\n└─────┴─────┘",
    "crumbs": [
      "Check functions",
      "has_no_infs"
    ]
  },
  {
    "objectID": "reference/has_no_infs.html#parameters",
    "href": "reference/has_no_infs.html#parameters",
    "title": "has_no_infs",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe input DataFrame to check for null values.\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for null value check. By default, all columns are checked.\nNone",
    "crumbs": [
      "Check functions",
      "has_no_infs"
    ]
  },
  {
    "objectID": "reference/has_no_infs.html#returns",
    "href": "reference/has_no_infs.html#returns",
    "title": "has_no_infs",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "has_no_infs"
    ]
  },
  {
    "objectID": "reference/has_no_infs.html#examples",
    "href": "reference/has_no_infs.html#examples",
    "title": "has_no_infs",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"a\": [1, 2],\n...         \"b\": [1.0, float(\"inf\")],\n...     }\n... )\n&gt;&gt;&gt; plg.has_no_infs(df)\nTraceback (most recent call last):\n  ...\npelage.checks.PolarsAssertError: Details\nshape: (1, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ f64 │\n╞═════╪═════╡\n│ 2   ┆ inf │\n└─────┴─────┘\nError with the DataFrame passed to the check function:\n--&gt;\n&gt;&gt;&gt; plg.has_no_infs(df, [\"a\"])  # or  plg.has_no_infs(df, \"a\")\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ f64 │\n╞═════╪═════╡\n│ 1   ┆ 1.0 │\n│ 2   ┆ inf │\n└─────┴─────┘",
    "crumbs": [
      "Check functions",
      "has_no_infs"
    ]
  },
  {
    "objectID": "reference/not_constant.html",
    "href": "reference/not_constant.html",
    "title": "not_constant",
    "section": "",
    "text": "checks.not_constant(data, columns=None)\nCheck if a DataFrame has constant columns.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe input DataFrame to check for null values.\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for null value check. By default, all columns are checked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df.pipe(plg.not_constant, \"a\")\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n└─────┘\n&gt;&gt;&gt; df = pl.DataFrame({\"b\": [1, 1]})\n&gt;&gt;&gt; df.pipe(plg.not_constant)\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 2)\n┌────────┬────────────┐\n│ column ┆ n_distinct │\n│ ---    ┆ ---        │\n│ str    ┆ u32        │\n╞════════╪════════════╡\n│ b      ┆ 1          │\n└────────┴────────────┘\nError with the DataFrame passed to the check function:\n--&gt;Some columns are constant",
    "crumbs": [
      "Check functions",
      "not_constant"
    ]
  },
  {
    "objectID": "reference/not_constant.html#parameters",
    "href": "reference/not_constant.html#parameters",
    "title": "not_constant",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe input DataFrame to check for null values.\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for null value check. By default, all columns are checked.\nNone",
    "crumbs": [
      "Check functions",
      "not_constant"
    ]
  },
  {
    "objectID": "reference/not_constant.html#returns",
    "href": "reference/not_constant.html#returns",
    "title": "not_constant",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "not_constant"
    ]
  },
  {
    "objectID": "reference/not_constant.html#examples",
    "href": "reference/not_constant.html#examples",
    "title": "not_constant",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df.pipe(plg.not_constant, \"a\")\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n└─────┘\n&gt;&gt;&gt; df = pl.DataFrame({\"b\": [1, 1]})\n&gt;&gt;&gt; df.pipe(plg.not_constant)\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 2)\n┌────────┬────────────┐\n│ column ┆ n_distinct │\n│ ---    ┆ ---        │\n│ str    ┆ u32        │\n╞════════╪════════════╡\n│ b      ┆ 1          │\n└────────┴────────────┘\nError with the DataFrame passed to the check function:\n--&gt;Some columns are constant",
    "crumbs": [
      "Check functions",
      "not_constant"
    ]
  },
  {
    "objectID": "reference/accepted_range.html",
    "href": "reference/accepted_range.html",
    "title": "accepted_range",
    "section": "",
    "text": "checks.accepted_range(data, items)\nCheck that all the values from specifed columns in the dict items are within the indicated range.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\n\nrequired\n\n\nitems\ntyping.Dict[str, pelage.checks.PolarsColumnBounds]\nAny type of inputs that match the following signature: column_name: (boundaries) where boundaries is compatible with the Polars methodis_between()` syntax. For example: { “col_a”: (low, high), “col_b”, (low_b, high_b, “right”), “col_c”, (low_c, high_c, “none”), … }\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df.pipe(plg.accepted_range, {\"a\": (0, 2)})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 3   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;Some values are beyond the acceptable ranges defined\n&gt;&gt;&gt; df.pipe(plg.accepted_range, {\"a\": (1, 3)})\nshape: (3, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n│ 3   │\n└─────┘\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [\"b\", \"c\"]})\n&gt;&gt;&gt; df.pipe(plg.accepted_range, {\"a\": (pl.lit(\"a\"), pl.lit(\"d\"), \"right\")})\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ str │\n╞═════╡\n│ b   │\n│ c   │\n└─────┘\n&gt;&gt;&gt; df.pipe(plg.accepted_range, {\"a\": (pl.lit(\"a\"), pl.lit(\"d\"), \"left\")})\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ str │\n╞═════╡\n│ b   │\n│ c   │\n└─────┘",
    "crumbs": [
      "Check functions",
      "accepted_range"
    ]
  },
  {
    "objectID": "reference/accepted_range.html#parameters",
    "href": "reference/accepted_range.html#parameters",
    "title": "accepted_range",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\n\nrequired\n\n\nitems\ntyping.Dict[str, pelage.checks.PolarsColumnBounds]\nAny type of inputs that match the following signature: column_name: (boundaries) where boundaries is compatible with the Polars methodis_between()` syntax. For example: { “col_a”: (low, high), “col_b”, (low_b, high_b, “right”), “col_c”, (low_c, high_c, “none”), … }\nrequired",
    "crumbs": [
      "Check functions",
      "accepted_range"
    ]
  },
  {
    "objectID": "reference/accepted_range.html#returns",
    "href": "reference/accepted_range.html#returns",
    "title": "accepted_range",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "accepted_range"
    ]
  },
  {
    "objectID": "reference/accepted_range.html#examples",
    "href": "reference/accepted_range.html#examples",
    "title": "accepted_range",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df.pipe(plg.accepted_range, {\"a\": (0, 2)})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 3   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;Some values are beyond the acceptable ranges defined\n&gt;&gt;&gt; df.pipe(plg.accepted_range, {\"a\": (1, 3)})\nshape: (3, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n│ 3   │\n└─────┘\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [\"b\", \"c\"]})\n&gt;&gt;&gt; df.pipe(plg.accepted_range, {\"a\": (pl.lit(\"a\"), pl.lit(\"d\"), \"right\")})\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ str │\n╞═════╡\n│ b   │\n│ c   │\n└─────┘\n&gt;&gt;&gt; df.pipe(plg.accepted_range, {\"a\": (pl.lit(\"a\"), pl.lit(\"d\"), \"left\")})\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ str │\n╞═════╡\n│ b   │\n│ c   │\n└─────┘",
    "crumbs": [
      "Check functions",
      "accepted_range"
    ]
  },
  {
    "objectID": "reference/custom_check.html",
    "href": "reference/custom_check.html",
    "title": "custom_check",
    "section": "",
    "text": "checks.custom_check(data, expresion)\nUse custom Polars expression to check the DataFrame, the expression when used through the dataframe method .filter() should return an empty dataframe. This expression should capture values that are not wanted in the dataframe. For instance, if a column should not contain the value 4, use the expression pl.col(\"column\") == 4.\nThough it may appear counter-intuitive, this behavior mimic the one proposed by DBT, and in order to facilitate interoperability between polars and DBT, it was decided to follow the same pattern\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\nexpresion\npolars.polars.Expr\nPolar Expression that can be passed to the .filter() method. As describe above, use an expression that should keep forbidden values when passed to the filter\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes.\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df.pipe(plg.custom_check, pl.col(\"a\") == 4)\nshape: (3, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n│ 3   │\n└─────┘\n&gt;&gt;&gt; df.pipe(plg.custom_check, pl.col(\"a\") == 3)\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 3   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;Unexpected data in `Custom Check`: [(col(\"a\")) == (3)]",
    "crumbs": [
      "Check functions",
      "custom_check"
    ]
  },
  {
    "objectID": "reference/custom_check.html#parameters",
    "href": "reference/custom_check.html#parameters",
    "title": "custom_check",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\nexpresion\npolars.polars.Expr\nPolar Expression that can be passed to the .filter() method. As describe above, use an expression that should keep forbidden values when passed to the filter\nrequired",
    "crumbs": [
      "Check functions",
      "custom_check"
    ]
  },
  {
    "objectID": "reference/custom_check.html#returns",
    "href": "reference/custom_check.html#returns",
    "title": "custom_check",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes.",
    "crumbs": [
      "Check functions",
      "custom_check"
    ]
  },
  {
    "objectID": "reference/custom_check.html#examples",
    "href": "reference/custom_check.html#examples",
    "title": "custom_check",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df.pipe(plg.custom_check, pl.col(\"a\") == 4)\nshape: (3, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n│ 3   │\n└─────┘\n&gt;&gt;&gt; df.pipe(plg.custom_check, pl.col(\"a\") == 3)\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 3   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;Unexpected data in `Custom Check`: [(col(\"a\")) == (3)]",
    "crumbs": [
      "Check functions",
      "custom_check"
    ]
  },
  {
    "objectID": "reference/at_least_one.html",
    "href": "reference/at_least_one.html",
    "title": "at_least_one",
    "section": "",
    "text": "checks.at_least_one(data, columns=None)\nEnsure that there is at least one not null value in the designated columns.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider to check the presence of at least one value. By default, all columns are checked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [None, None], \"b\": [1, None]})\n&gt;&gt;&gt; df.pipe(plg.at_least_one, \"b\")\nshape: (2, 2)\n┌──────┬──────┐\n│ a    ┆ b    │\n│ ---  ┆ ---  │\n│ null ┆ i64  │\n╞══════╪══════╡\n│ null ┆ 1    │\n│ null ┆ null │\n└──────┴──────┘\n&gt;&gt;&gt; df.pipe(plg.at_least_one)\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Some columns contains only null values: ['a']",
    "crumbs": [
      "Check functions",
      "at_least_one"
    ]
  },
  {
    "objectID": "reference/at_least_one.html#parameters",
    "href": "reference/at_least_one.html#parameters",
    "title": "at_least_one",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider to check the presence of at least one value. By default, all columns are checked.\nNone",
    "crumbs": [
      "Check functions",
      "at_least_one"
    ]
  },
  {
    "objectID": "reference/at_least_one.html#returns",
    "href": "reference/at_least_one.html#returns",
    "title": "at_least_one",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "at_least_one"
    ]
  },
  {
    "objectID": "reference/at_least_one.html#examples",
    "href": "reference/at_least_one.html#examples",
    "title": "at_least_one",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [None, None], \"b\": [1, None]})\n&gt;&gt;&gt; df.pipe(plg.at_least_one, \"b\")\nshape: (2, 2)\n┌──────┬──────┐\n│ a    ┆ b    │\n│ ---  ┆ ---  │\n│ null ┆ i64  │\n╞══════╪══════╡\n│ null ┆ 1    │\n│ null ┆ null │\n└──────┴──────┘\n&gt;&gt;&gt; df.pipe(plg.at_least_one)\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Some columns contains only null values: ['a']",
    "crumbs": [
      "Check functions",
      "at_least_one"
    ]
  },
  {
    "objectID": "reference/has_shape.html",
    "href": "reference/has_shape.html",
    "title": "has_shape",
    "section": "",
    "text": "checks.has_shape(data, shape)\nCheck if a DataFrame has the specified shape\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nInput data\nrequired\n\n\nshape\ntyping.Tuple[int, int]\nTuple with the expected dataframe shape, as from the .shape() method\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2], \"b\": [\"a\", \"b\"]})\n&gt;&gt;&gt; df.pipe(plg.has_shape, (2, 2))\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n└─────┴─────┘\n&gt;&gt;&gt; df.pipe(plg.has_shape, (1, 2))\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;The data has not the expected shape",
    "crumbs": [
      "Check functions",
      "has_shape"
    ]
  },
  {
    "objectID": "reference/has_shape.html#parameters",
    "href": "reference/has_shape.html#parameters",
    "title": "has_shape",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nInput data\nrequired\n\n\nshape\ntyping.Tuple[int, int]\nTuple with the expected dataframe shape, as from the .shape() method\nrequired",
    "crumbs": [
      "Check functions",
      "has_shape"
    ]
  },
  {
    "objectID": "reference/has_shape.html#returns",
    "href": "reference/has_shape.html#returns",
    "title": "has_shape",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "has_shape"
    ]
  },
  {
    "objectID": "reference/has_shape.html#examples",
    "href": "reference/has_shape.html#examples",
    "title": "has_shape",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2], \"b\": [\"a\", \"b\"]})\n&gt;&gt;&gt; df.pipe(plg.has_shape, (2, 2))\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n└─────┴─────┘\n&gt;&gt;&gt; df.pipe(plg.has_shape, (1, 2))\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;The data has not the expected shape",
    "crumbs": [
      "Check functions",
      "has_shape"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Functions to inspect docstrings.\n\n\n\nhas_shape\nCheck if a DataFrame has the specified shape\n\n\nhas_columns\nCheck if a DataFrame has the specified\n\n\nhas_dtypes\nCheck that the columns have the expected types\n\n\nhas_no_nulls\nCheck if a DataFrame has any null (missing) values.\n\n\nhas_no_infs\nCheck if a DataFrame has any infinite (inf) values.\n\n\nunique\nCheck if there are no duplicated values in each one of the selected columns\n\n\nunique_combination_of_columns\nEnsure that the selected column have a unique combination per row.\n\n\nnot_constant\nCheck if a DataFrame has constant columns.\n\n\naccepted_values\nRaises error if columns contains values not specified in items\n\n\nnot_accepted_values\nRaises error if columns contains values specified in List of forbbiden items\n\n\nhas_mandatory_values\nEnsure that all specified values are present in their respective column.\n\n\nnot_null_proportion\nsserts that the proportion of non-null values present in a column is between\n\n\nat_least_one\nEnsure that there is at least one not null value in the designated columns.\n\n\naccepted_range\nCheck that all the values from specifed columns in the dict items are within\n\n\nmaintains_relationships\nFunction to help ensuring that set of values in selected column remains the\n\n\nis_monotonic\nVerify that values in a column are consecutively increasing or decreasing\n\n\ncustom_check\nUse custom Polars expression to check the DataFrame, the expression when used\n\n\nmutually_exclusive_ranges\nEnsure that the specified columns contains no overlapping intervals.\n\n\ncolumn_is_within_n_std\nFunction asserting values are within a given STD range, thus ensuring the absence\n\n\n\n\n\n\nTypes aliases and custom exceptions\n\n\n\nPolarsAssertError",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#check-functions",
    "href": "reference/index.html#check-functions",
    "title": "Function reference",
    "section": "",
    "text": "Functions to inspect docstrings.\n\n\n\nhas_shape\nCheck if a DataFrame has the specified shape\n\n\nhas_columns\nCheck if a DataFrame has the specified\n\n\nhas_dtypes\nCheck that the columns have the expected types\n\n\nhas_no_nulls\nCheck if a DataFrame has any null (missing) values.\n\n\nhas_no_infs\nCheck if a DataFrame has any infinite (inf) values.\n\n\nunique\nCheck if there are no duplicated values in each one of the selected columns\n\n\nunique_combination_of_columns\nEnsure that the selected column have a unique combination per row.\n\n\nnot_constant\nCheck if a DataFrame has constant columns.\n\n\naccepted_values\nRaises error if columns contains values not specified in items\n\n\nnot_accepted_values\nRaises error if columns contains values specified in List of forbbiden items\n\n\nhas_mandatory_values\nEnsure that all specified values are present in their respective column.\n\n\nnot_null_proportion\nsserts that the proportion of non-null values present in a column is between\n\n\nat_least_one\nEnsure that there is at least one not null value in the designated columns.\n\n\naccepted_range\nCheck that all the values from specifed columns in the dict items are within\n\n\nmaintains_relationships\nFunction to help ensuring that set of values in selected column remains the\n\n\nis_monotonic\nVerify that values in a column are consecutively increasing or decreasing\n\n\ncustom_check\nUse custom Polars expression to check the DataFrame, the expression when used\n\n\nmutually_exclusive_ranges\nEnsure that the specified columns contains no overlapping intervals.\n\n\ncolumn_is_within_n_std\nFunction asserting values are within a given STD range, thus ensuring the absence",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#exceptions",
    "href": "reference/index.html#exceptions",
    "title": "Function reference",
    "section": "",
    "text": "Types aliases and custom exceptions\n\n\n\nPolarsAssertError",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/is_monotonic.html",
    "href": "reference/is_monotonic.html",
    "title": "is_monotonic",
    "section": "",
    "text": "checks.is_monotonic(data, column, decreasing=False, strict=True)\nVerify that values in a column are consecutively increasing or decreasing\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\ncolumn\nstr\nName of the column that should be monotonic.\nrequired\n\n\ndecreasing\nbool\nShould the column be decreasing, by default False\nFalse\n\n\nstrict\nbool\nThe series must be stricly increasing or decreasing, no consecutive equal values are allowed, by default True\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df =     given = pl.DataFrame({\"int\": [1, 2, 1]})\n&gt;&gt;&gt; df = pl.DataFrame({\"int\": [1, 2, 3], \"str\": [\"x\", \"y\", \"z\"]})\n&gt;&gt;&gt; df.pipe(plg.is_monotonic, \"int\")\nshape: (3, 2)\n┌─────┬─────┐\n│ int ┆ str │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ x   │\n│ 2   ┆ y   │\n│ 3   ┆ z   │\n└─────┴─────┘\n&gt;&gt;&gt; bad = pl.DataFrame({\"int\": [1, 2, 1], \"str\": [\"x\", \"y\", \"z\"]})\n&gt;&gt;&gt; bad.pipe(plg.is_monotonic, \"int\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Column \"int\" expected to be monotonic but is not, try .sort(\"int\")",
    "crumbs": [
      "Check functions",
      "is_monotonic"
    ]
  },
  {
    "objectID": "reference/is_monotonic.html#parameters",
    "href": "reference/is_monotonic.html#parameters",
    "title": "is_monotonic",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\ncolumn\nstr\nName of the column that should be monotonic.\nrequired\n\n\ndecreasing\nbool\nShould the column be decreasing, by default False\nFalse\n\n\nstrict\nbool\nThe series must be stricly increasing or decreasing, no consecutive equal values are allowed, by default True\nTrue",
    "crumbs": [
      "Check functions",
      "is_monotonic"
    ]
  },
  {
    "objectID": "reference/is_monotonic.html#returns",
    "href": "reference/is_monotonic.html#returns",
    "title": "is_monotonic",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "is_monotonic"
    ]
  },
  {
    "objectID": "reference/is_monotonic.html#examples",
    "href": "reference/is_monotonic.html#examples",
    "title": "is_monotonic",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df =     given = pl.DataFrame({\"int\": [1, 2, 1]})\n&gt;&gt;&gt; df = pl.DataFrame({\"int\": [1, 2, 3], \"str\": [\"x\", \"y\", \"z\"]})\n&gt;&gt;&gt; df.pipe(plg.is_monotonic, \"int\")\nshape: (3, 2)\n┌─────┬─────┐\n│ int ┆ str │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ x   │\n│ 2   ┆ y   │\n│ 3   ┆ z   │\n└─────┴─────┘\n&gt;&gt;&gt; bad = pl.DataFrame({\"int\": [1, 2, 1], \"str\": [\"x\", \"y\", \"z\"]})\n&gt;&gt;&gt; bad.pipe(plg.is_monotonic, \"int\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Column \"int\" expected to be monotonic but is not, try .sort(\"int\")",
    "crumbs": [
      "Check functions",
      "is_monotonic"
    ]
  },
  {
    "objectID": "reference/not_null_proportion.html",
    "href": "reference/not_null_proportion.html",
    "title": "not_null_proportion",
    "section": "",
    "text": "checks.not_null_proportion(data, items)\nsserts that the proportion of non-null values present in a column is between a specified range [at_least, at_most] where at_most is an optional argument (default: 1.0).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\ndescription\nrequired\n\n\nitems\ntyping.Dict[str, float | typing.Tuple[float, float]]\nLimit ranges for the proportion of not null value for selected columns. Any of the following formats is valid: { “column_name_a” : 0.333, “column_name_b” : (0.25, 0.44), } When specifying a single float, the higher bound of the range will automatically be set to 1.0, i.e. (given_float, 1.0)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...         {\n...             \"a\": [1, None, None],\n...             \"b\": [1, 2, None],\n...         }\n...     )\n&gt;&gt;&gt; df.pipe(plg.not_null_proportion, {\"a\": 0.33, \"b\": 0.66})\nshape: (3, 2)\n┌──────┬──────┐\n│ a    ┆ b    │\n│ ---  ┆ ---  │\n│ i64  ┆ i64  │\n╞══════╪══════╡\n│ 1    ┆ 1    │\n│ null ┆ 2    │\n│ null ┆ null │\n└──────┴──────┘\n&gt;&gt;&gt; df.pipe(plg.not_null_proportion, {\"a\": 0.7})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 4)\n┌────────┬─────────────────────┬──────────┬──────────┐\n│ column ┆ not_null_proportion ┆ min_prop ┆ max_prop │\n│ ---    ┆ ---                 ┆ ---      ┆ ---      │\n│ str    ┆ f64                 ┆ f64      ┆ i64      │\n╞════════╪═════════════════════╪══════════╪══════════╡\n│ a      ┆ 0.333333            ┆ 0.7      ┆ 1        │\n└────────┴─────────────────────┴──────────┴──────────┘\nError with the DataFrame passed to the check function:\n--&gt;Some columns contains a proportion of nulls beyond specified limits",
    "crumbs": [
      "Check functions",
      "not_null_proportion"
    ]
  },
  {
    "objectID": "reference/not_null_proportion.html#parameters",
    "href": "reference/not_null_proportion.html#parameters",
    "title": "not_null_proportion",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\ndescription\nrequired\n\n\nitems\ntyping.Dict[str, float | typing.Tuple[float, float]]\nLimit ranges for the proportion of not null value for selected columns. Any of the following formats is valid: { “column_name_a” : 0.333, “column_name_b” : (0.25, 0.44), } When specifying a single float, the higher bound of the range will automatically be set to 1.0, i.e. (given_float, 1.0)\nrequired",
    "crumbs": [
      "Check functions",
      "not_null_proportion"
    ]
  },
  {
    "objectID": "reference/not_null_proportion.html#returns",
    "href": "reference/not_null_proportion.html#returns",
    "title": "not_null_proportion",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "not_null_proportion"
    ]
  },
  {
    "objectID": "reference/not_null_proportion.html#examples",
    "href": "reference/not_null_proportion.html#examples",
    "title": "not_null_proportion",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...         {\n...             \"a\": [1, None, None],\n...             \"b\": [1, 2, None],\n...         }\n...     )\n&gt;&gt;&gt; df.pipe(plg.not_null_proportion, {\"a\": 0.33, \"b\": 0.66})\nshape: (3, 2)\n┌──────┬──────┐\n│ a    ┆ b    │\n│ ---  ┆ ---  │\n│ i64  ┆ i64  │\n╞══════╪══════╡\n│ 1    ┆ 1    │\n│ null ┆ 2    │\n│ null ┆ null │\n└──────┴──────┘\n&gt;&gt;&gt; df.pipe(plg.not_null_proportion, {\"a\": 0.7})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 4)\n┌────────┬─────────────────────┬──────────┬──────────┐\n│ column ┆ not_null_proportion ┆ min_prop ┆ max_prop │\n│ ---    ┆ ---                 ┆ ---      ┆ ---      │\n│ str    ┆ f64                 ┆ f64      ┆ i64      │\n╞════════╪═════════════════════╪══════════╪══════════╡\n│ a      ┆ 0.333333            ┆ 0.7      ┆ 1        │\n└────────┴─────────────────────┴──────────┴──────────┘\nError with the DataFrame passed to the check function:\n--&gt;Some columns contains a proportion of nulls beyond specified limits",
    "crumbs": [
      "Check functions",
      "not_null_proportion"
    ]
  },
  {
    "objectID": "reference/accepted_values.html",
    "href": "reference/accepted_values.html",
    "title": "accepted_values",
    "section": "",
    "text": "checks.accepted_values(data, items)\nRaises error if columns contains values not specified in items\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\n\nrequired\n\n\nitems\ntyping.Dict[str, typing.List]\nA dictionnary where keys are a string compatible with a pl.Expr, to be used with pl.col(). The value for each key is a List of all authorized values in the dataframe.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; items = {\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df = pl.DataFrame(items)\n&gt;&gt;&gt; df.pipe(plg.accepted_values, {\"a\": [1, 2, 3]})\nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n│ 3   ┆ c   │\n└─────┴─────┘\n&gt;&gt;&gt; df.pipe(plg.accepted_values, {\"a\": [1, 2]})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 3   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;It contains values that have not been white-Listed in `items`.\nShowing problematic columns only.",
    "crumbs": [
      "Check functions",
      "accepted_values"
    ]
  },
  {
    "objectID": "reference/accepted_values.html#parameters",
    "href": "reference/accepted_values.html#parameters",
    "title": "accepted_values",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\n\nrequired\n\n\nitems\ntyping.Dict[str, typing.List]\nA dictionnary where keys are a string compatible with a pl.Expr, to be used with pl.col(). The value for each key is a List of all authorized values in the dataframe.\nrequired",
    "crumbs": [
      "Check functions",
      "accepted_values"
    ]
  },
  {
    "objectID": "reference/accepted_values.html#returns",
    "href": "reference/accepted_values.html#returns",
    "title": "accepted_values",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "accepted_values"
    ]
  },
  {
    "objectID": "reference/accepted_values.html#examples",
    "href": "reference/accepted_values.html#examples",
    "title": "accepted_values",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; items = {\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df = pl.DataFrame(items)\n&gt;&gt;&gt; df.pipe(plg.accepted_values, {\"a\": [1, 2, 3]})\nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n│ 3   ┆ c   │\n└─────┴─────┘\n&gt;&gt;&gt; df.pipe(plg.accepted_values, {\"a\": [1, 2]})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 3   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;It contains values that have not been white-Listed in `items`.\nShowing problematic columns only.",
    "crumbs": [
      "Check functions",
      "accepted_values"
    ]
  },
  {
    "objectID": "reference/PolarsColumnType.html",
    "href": "reference/PolarsColumnType.html",
    "title": "PolarsColumnType",
    "section": "",
    "text": "PolarsColumnType\nchecks.PolarsColumnType"
  },
  {
    "objectID": "reference/unique.html",
    "href": "reference/unique.html",
    "title": "unique",
    "section": "",
    "text": "checks.unique(data, columns=None)\nCheck if there are no duplicated values in each one of the selected columns independently, i.e. it is a column oriented check.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe input DataFrame to check for unique values.\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for uniqueness check. By default, all columns are checked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df.pipe(plg.unique, \"a\")  # Can also use [\"a\", ...], pl.col(\"a)\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n└─────┘\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 1, 2]})\n&gt;&gt;&gt; df.pipe(plg.unique, \"a\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 1   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;Somes values are duplicated within the specified columns",
    "crumbs": [
      "Check functions",
      "unique"
    ]
  },
  {
    "objectID": "reference/unique.html#parameters",
    "href": "reference/unique.html#parameters",
    "title": "unique",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe input DataFrame to check for unique values.\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for uniqueness check. By default, all columns are checked.\nNone",
    "crumbs": [
      "Check functions",
      "unique"
    ]
  },
  {
    "objectID": "reference/unique.html#returns",
    "href": "reference/unique.html#returns",
    "title": "unique",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "unique"
    ]
  },
  {
    "objectID": "reference/unique.html#examples",
    "href": "reference/unique.html#examples",
    "title": "unique",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df.pipe(plg.unique, \"a\")  # Can also use [\"a\", ...], pl.col(\"a)\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n└─────┘\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 1, 2]})\n&gt;&gt;&gt; df.pipe(plg.unique, \"a\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 1   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;Somes values are duplicated within the specified columns",
    "crumbs": [
      "Check functions",
      "unique"
    ]
  },
  {
    "objectID": "reference/has_dtypes.html",
    "href": "reference/has_dtypes.html",
    "title": "has_dtypes",
    "section": "",
    "text": "checks.has_dtypes(data, items)\nCheck that the columns have the expected types\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\nitems\ntyping.Dict[str, polars.type_aliases.PolarsDataType]\nA dictionnary of column name with their expected polars data type : {     \"col_a\": pl.String,     \"col_b\": pl.Int64,     \"col_c\": pl.Float64,     ... }\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pelage import checks\n&gt;&gt;&gt; df = pl.DataFrame({\n...     \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n...     \"age\": [20, 30, 40],\n...     \"city\": [\"New York\", \"London\", \"Paris\"],\n... })\n&gt;&gt;&gt; checks.has_dtypes(df, {\n...     \"name\": pl.String,\n...     \"age\": pl.Int64,\n...     \"city\": pl.String,\n... })\nshape: (3, 3)\n┌─────────┬─────┬──────────┐\n│ name    ┆ age ┆ city     │\n│ ---     ┆ --- ┆ ---      │\n│ str     ┆ i64 ┆ str      │\n╞═════════╪═════╪══════════╡\n│ Alice   ┆ 20  ┆ New York │\n│ Bob     ┆ 30  ┆ London   │\n│ Charlie ┆ 40  ┆ Paris    │\n└─────────┴─────┴──────────┘\n&gt;&gt;&gt; checks.has_dtypes(df, {\n...     \"age\": pl.String,\n...     \"city\": pl.Int64,\n... })\nTraceback (most recent call last):\n    ...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Some columns don't have the expected type:\ncolumn='age', expected_type=String, real_dtype=Int64\ncolumn='city', expected_type=Int64, real_dtype=String",
    "crumbs": [
      "Check functions",
      "has_dtypes"
    ]
  },
  {
    "objectID": "reference/has_dtypes.html#parameters",
    "href": "reference/has_dtypes.html#parameters",
    "title": "has_dtypes",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\nitems\ntyping.Dict[str, polars.type_aliases.PolarsDataType]\nA dictionnary of column name with their expected polars data type : {     \"col_a\": pl.String,     \"col_b\": pl.Int64,     \"col_c\": pl.Float64,     ... }\nrequired",
    "crumbs": [
      "Check functions",
      "has_dtypes"
    ]
  },
  {
    "objectID": "reference/has_dtypes.html#returns",
    "href": "reference/has_dtypes.html#returns",
    "title": "has_dtypes",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "has_dtypes"
    ]
  },
  {
    "objectID": "reference/has_dtypes.html#examples",
    "href": "reference/has_dtypes.html#examples",
    "title": "has_dtypes",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pelage import checks\n&gt;&gt;&gt; df = pl.DataFrame({\n...     \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n...     \"age\": [20, 30, 40],\n...     \"city\": [\"New York\", \"London\", \"Paris\"],\n... })\n&gt;&gt;&gt; checks.has_dtypes(df, {\n...     \"name\": pl.String,\n...     \"age\": pl.Int64,\n...     \"city\": pl.String,\n... })\nshape: (3, 3)\n┌─────────┬─────┬──────────┐\n│ name    ┆ age ┆ city     │\n│ ---     ┆ --- ┆ ---      │\n│ str     ┆ i64 ┆ str      │\n╞═════════╪═════╪══════════╡\n│ Alice   ┆ 20  ┆ New York │\n│ Bob     ┆ 30  ┆ London   │\n│ Charlie ┆ 40  ┆ Paris    │\n└─────────┴─────┴──────────┘\n&gt;&gt;&gt; checks.has_dtypes(df, {\n...     \"age\": pl.String,\n...     \"city\": pl.Int64,\n... })\nTraceback (most recent call last):\n    ...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Some columns don't have the expected type:\ncolumn='age', expected_type=String, real_dtype=Int64\ncolumn='city', expected_type=Int64, real_dtype=String",
    "crumbs": [
      "Check functions",
      "has_dtypes"
    ]
  },
  {
    "objectID": "reference/has_columns.html",
    "href": "reference/has_columns.html",
    "title": "has_columns",
    "section": "",
    "text": "checks.has_columns(data, names)\nCheck if a DataFrame has the specified\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe DataFrame to check for column presence.\nrequired\n\n\nnames\ntyping.Union[str, typing.List[str]]\nThe names of the columns to check.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df.pipe(plg.has_columns, \"b\")\nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n│ 3   ┆ c   │\n└─────┴─────┘\n&gt;&gt;&gt; df.pipe(plg.has_columns, \"c\")\nTraceback (most recent call last):\n    ...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;\n&gt;&gt;&gt; df.pipe(plg.has_columns, [\"a\", \"b\"])\nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n│ 3   ┆ c   │\n└─────┴─────┘\n&gt;&gt;&gt;",
    "crumbs": [
      "Check functions",
      "has_columns"
    ]
  },
  {
    "objectID": "reference/has_columns.html#parameters",
    "href": "reference/has_columns.html#parameters",
    "title": "has_columns",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe DataFrame to check for column presence.\nrequired\n\n\nnames\ntyping.Union[str, typing.List[str]]\nThe names of the columns to check.\nrequired",
    "crumbs": [
      "Check functions",
      "has_columns"
    ]
  },
  {
    "objectID": "reference/has_columns.html#returns",
    "href": "reference/has_columns.html#returns",
    "title": "has_columns",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "has_columns"
    ]
  },
  {
    "objectID": "reference/has_columns.html#examples",
    "href": "reference/has_columns.html#examples",
    "title": "has_columns",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df.pipe(plg.has_columns, \"b\")\nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n│ 3   ┆ c   │\n└─────┴─────┘\n&gt;&gt;&gt; df.pipe(plg.has_columns, \"c\")\nTraceback (most recent call last):\n    ...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;\n&gt;&gt;&gt; df.pipe(plg.has_columns, [\"a\", \"b\"])\nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n│ 3   ┆ c   │\n└─────┴─────┘\n&gt;&gt;&gt;",
    "crumbs": [
      "Check functions",
      "has_columns"
    ]
  },
  {
    "objectID": "reference/has_mandatory_values.html",
    "href": "reference/has_mandatory_values.html",
    "title": "has_mandatory_values",
    "section": "",
    "text": "checks.has_mandatory_values(data, items)\nEnsure that all specified values are present in their respective column.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\nitems\ntyping.Dict[str, list]\ndescription\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df.pipe(plg.has_mandatory_values, {\"a\": [1, 2]})\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n└─────┘\n&gt;&gt;&gt; df.pipe(plg.has_mandatory_values, {\"a\": [3, 4]})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Missing mandatory values in the following columns: {'a': [3, 4]}",
    "crumbs": [
      "Check functions",
      "has_mandatory_values"
    ]
  },
  {
    "objectID": "reference/has_mandatory_values.html#parameters",
    "href": "reference/has_mandatory_values.html#parameters",
    "title": "has_mandatory_values",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check\nrequired\n\n\nitems\ntyping.Dict[str, list]\ndescription\nrequired",
    "crumbs": [
      "Check functions",
      "has_mandatory_values"
    ]
  },
  {
    "objectID": "reference/has_mandatory_values.html#returns",
    "href": "reference/has_mandatory_values.html#returns",
    "title": "has_mandatory_values",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "has_mandatory_values"
    ]
  },
  {
    "objectID": "reference/has_mandatory_values.html#examples",
    "href": "reference/has_mandatory_values.html#examples",
    "title": "has_mandatory_values",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df.pipe(plg.has_mandatory_values, {\"a\": [1, 2]})\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ i64 │\n╞═════╡\n│ 1   │\n│ 2   │\n└─────┘\n&gt;&gt;&gt; df.pipe(plg.has_mandatory_values, {\"a\": [3, 4]})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Missing mandatory values in the following columns: {'a': [3, 4]}",
    "crumbs": [
      "Check functions",
      "has_mandatory_values"
    ]
  },
  {
    "objectID": "reference/mutually_exclusive_ranges.html",
    "href": "reference/mutually_exclusive_ranges.html",
    "title": "mutually_exclusive_ranges",
    "section": "",
    "text": "checks.mutually_exclusive_ranges(data, low_bound, high_bound, partition_by=None)\nEnsure that the specified columns contains no overlapping intervals.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nData to check\nrequired\n\n\nlow_bound\nstr\nName of column containing the lower bound of the interval\nrequired\n\n\nhigh_bound\nstr\nName of column containing the higher bound of the interval\nrequired\n\n\npartition_by\npolars.type_aliases.IntoExpr | typing.Iterable[polars.type_aliases.IntoExpr]\nParameter compatible with .over() function to split the check by groups, by default None\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...     [\n...         [1, 2],\n...         [3, 4],\n...     ],\n...     schema=[\"a\", \"b\"], orient=\"row\"\n... )\n&gt;&gt;&gt; df.pipe(plg.mutually_exclusive_ranges, low_bound=\"a\", high_bound=\"b\")\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ i64 │\n╞═════╪═════╡\n│ 1   ┆ 2   │\n│ 3   ┆ 4   │\n└─────┴─────┘\n&gt;&gt;&gt; df = pl.DataFrame(\n...     [\n...         [1, 3],\n...         [2, 4],\n...         [5, 7],\n...         [6, 8],\n...         [9, 9],\n...     ],\n...     schema=[\"a\", \"b\"],\n...     orient=\"row\",\n... )\n&gt;&gt;&gt; df.pipe(plg.mutually_exclusive_ranges, low_bound=\"a\", high_bound=\"b\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (4, 3)\n┌───────┬─────┬─────┐\n│ index ┆ a   ┆ b   │\n│ ---   ┆ --- ┆ --- │\n│ u32   ┆ i64 ┆ i64 │\n╞═══════╪═════╪═════╡\n│ 0     ┆ 1   ┆ 3   │\n│ 1     ┆ 2   ┆ 4   │\n│ 2     ┆ 5   ┆ 7   │\n│ 3     ┆ 6   ┆ 8   │\n└───────┴─────┴─────┘\nError with the DataFrame passed to the check function:\n--&gt;There were overlapping intervals:\nDataFrame was sorted by: ['a', 'b'],\nInterval columns: low_bound='a', high_bound='b'",
    "crumbs": [
      "Check functions",
      "mutually_exclusive_ranges"
    ]
  },
  {
    "objectID": "reference/mutually_exclusive_ranges.html#parameters",
    "href": "reference/mutually_exclusive_ranges.html#parameters",
    "title": "mutually_exclusive_ranges",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nData to check\nrequired\n\n\nlow_bound\nstr\nName of column containing the lower bound of the interval\nrequired\n\n\nhigh_bound\nstr\nName of column containing the higher bound of the interval\nrequired\n\n\npartition_by\npolars.type_aliases.IntoExpr | typing.Iterable[polars.type_aliases.IntoExpr]\nParameter compatible with .over() function to split the check by groups, by default None\nNone",
    "crumbs": [
      "Check functions",
      "mutually_exclusive_ranges"
    ]
  },
  {
    "objectID": "reference/mutually_exclusive_ranges.html#returns",
    "href": "reference/mutually_exclusive_ranges.html#returns",
    "title": "mutually_exclusive_ranges",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "mutually_exclusive_ranges"
    ]
  },
  {
    "objectID": "reference/mutually_exclusive_ranges.html#examples",
    "href": "reference/mutually_exclusive_ranges.html#examples",
    "title": "mutually_exclusive_ranges",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...     [\n...         [1, 2],\n...         [3, 4],\n...     ],\n...     schema=[\"a\", \"b\"], orient=\"row\"\n... )\n&gt;&gt;&gt; df.pipe(plg.mutually_exclusive_ranges, low_bound=\"a\", high_bound=\"b\")\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ i64 │\n╞═════╪═════╡\n│ 1   ┆ 2   │\n│ 3   ┆ 4   │\n└─────┴─────┘\n&gt;&gt;&gt; df = pl.DataFrame(\n...     [\n...         [1, 3],\n...         [2, 4],\n...         [5, 7],\n...         [6, 8],\n...         [9, 9],\n...     ],\n...     schema=[\"a\", \"b\"],\n...     orient=\"row\",\n... )\n&gt;&gt;&gt; df.pipe(plg.mutually_exclusive_ranges, low_bound=\"a\", high_bound=\"b\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (4, 3)\n┌───────┬─────┬─────┐\n│ index ┆ a   ┆ b   │\n│ ---   ┆ --- ┆ --- │\n│ u32   ┆ i64 ┆ i64 │\n╞═══════╪═════╪═════╡\n│ 0     ┆ 1   ┆ 3   │\n│ 1     ┆ 2   ┆ 4   │\n│ 2     ┆ 5   ┆ 7   │\n│ 3     ┆ 6   ┆ 8   │\n└───────┴─────┴─────┘\nError with the DataFrame passed to the check function:\n--&gt;There were overlapping intervals:\nDataFrame was sorted by: ['a', 'b'],\nInterval columns: low_bound='a', high_bound='b'",
    "crumbs": [
      "Check functions",
      "mutually_exclusive_ranges"
    ]
  },
  {
    "objectID": "reference/PolarsOverClauseInput.html",
    "href": "reference/PolarsOverClauseInput.html",
    "title": "PolarsOverClauseInput",
    "section": "",
    "text": "PolarsOverClauseInput\nchecks.PolarsOverClauseInput"
  },
  {
    "objectID": "reference/column_is_within_n_std.html",
    "href": "reference/column_is_within_n_std.html",
    "title": "column_is_within_n_std",
    "section": "",
    "text": "checks.column_is_within_n_std(data, items, *args)\nFunction asserting values are within a given STD range, thus ensuring the absence of outliers.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check.\nrequired\n\n\nitems\ntyping.Tuple[pelage.checks.PolarsColumnType, int]\nA column name / column type with the number of STD authorized for the values within. Must be of the following form: (col_name, n_std)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"a\": list(range(0, 11)),\n...         \"b\": list(range(0, 11)),\n...         \"c\": list(range(0, 10)) + [5000],\n...     }\n... )\n&gt;&gt;&gt; df.pipe(plg.column_is_within_n_std, (\"a\", 2), (\"b\", 3))\nshape: (11, 3)\n┌─────┬─────┬──────┐\n│ a   ┆ b   ┆ c    │\n│ --- ┆ --- ┆ ---  │\n│ i64 ┆ i64 ┆ i64  │\n╞═════╪═════╪══════╡\n│ 0   ┆ 0   ┆ 0    │\n│ 1   ┆ 1   ┆ 1    │\n│ 2   ┆ 2   ┆ 2    │\n│ 3   ┆ 3   ┆ 3    │\n│ 4   ┆ 4   ┆ 4    │\n│ …   ┆ …   ┆ …    │\n│ 6   ┆ 6   ┆ 6    │\n│ 7   ┆ 7   ┆ 7    │\n│ 8   ┆ 8   ┆ 8    │\n│ 9   ┆ 9   ┆ 9    │\n│ 10  ┆ 10  ┆ 5000 │\n└─────┴─────┴──────┘\n&gt;&gt;&gt; df.pipe(plg.column_is_within_n_std, (\"b\", 2), (\"c\", 2))\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 1)\n┌──────┐\n│ c    │\n│ ---  │\n│ i64  │\n╞══════╡\n│ 5000 │\n└──────┘\nError with the DataFrame passed to the check function:\n--&gt;There are some outliers outside the specified mean±std range\nImpacted columns: ['c']",
    "crumbs": [
      "Check functions",
      "column_is_within_n_std"
    ]
  },
  {
    "objectID": "reference/column_is_within_n_std.html#parameters",
    "href": "reference/column_is_within_n_std.html#parameters",
    "title": "column_is_within_n_std",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nTo check.\nrequired\n\n\nitems\ntyping.Tuple[pelage.checks.PolarsColumnType, int]\nA column name / column type with the number of STD authorized for the values within. Must be of the following form: (col_name, n_std)\nrequired",
    "crumbs": [
      "Check functions",
      "column_is_within_n_std"
    ]
  },
  {
    "objectID": "reference/column_is_within_n_std.html#returns",
    "href": "reference/column_is_within_n_std.html#returns",
    "title": "column_is_within_n_std",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "column_is_within_n_std"
    ]
  },
  {
    "objectID": "reference/column_is_within_n_std.html#examples",
    "href": "reference/column_is_within_n_std.html#examples",
    "title": "column_is_within_n_std",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"a\": list(range(0, 11)),\n...         \"b\": list(range(0, 11)),\n...         \"c\": list(range(0, 10)) + [5000],\n...     }\n... )\n&gt;&gt;&gt; df.pipe(plg.column_is_within_n_std, (\"a\", 2), (\"b\", 3))\nshape: (11, 3)\n┌─────┬─────┬──────┐\n│ a   ┆ b   ┆ c    │\n│ --- ┆ --- ┆ ---  │\n│ i64 ┆ i64 ┆ i64  │\n╞═════╪═════╪══════╡\n│ 0   ┆ 0   ┆ 0    │\n│ 1   ┆ 1   ┆ 1    │\n│ 2   ┆ 2   ┆ 2    │\n│ 3   ┆ 3   ┆ 3    │\n│ 4   ┆ 4   ┆ 4    │\n│ …   ┆ …   ┆ …    │\n│ 6   ┆ 6   ┆ 6    │\n│ 7   ┆ 7   ┆ 7    │\n│ 8   ┆ 8   ┆ 8    │\n│ 9   ┆ 9   ┆ 9    │\n│ 10  ┆ 10  ┆ 5000 │\n└─────┴─────┴──────┘\n&gt;&gt;&gt; df.pipe(plg.column_is_within_n_std, (\"b\", 2), (\"c\", 2))\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 1)\n┌──────┐\n│ c    │\n│ ---  │\n│ i64  │\n╞══════╡\n│ 5000 │\n└──────┘\nError with the DataFrame passed to the check function:\n--&gt;There are some outliers outside the specified mean±std range\nImpacted columns: ['c']",
    "crumbs": [
      "Check functions",
      "column_is_within_n_std"
    ]
  },
  {
    "objectID": "reference/maintains_relationships.html",
    "href": "reference/maintains_relationships.html",
    "title": "maintains_relationships",
    "section": "",
    "text": "checks.maintains_relationships(data, other_df, column)\nFunction to help ensuring that set of values in selected column remains the same in both DataFrames. This helps to maintain referential integrity.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nDataframe after transformation\nrequired\n\n\nother_df\npolars.polars.DataFrame\nDistant dataframe usually the one before transformation\nrequired\n\n\ncolumn\nstr\nColumn to check for keys/ids\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; initial_df = pl.DataFrame({\"a\": [\"a\", \"b\"]})\n&gt;&gt;&gt; final_df = pl.DataFrame({\"a\": [\"a\", \"b\"]})\n&gt;&gt;&gt; final_df.pipe(plg.maintains_relationships, initial_df, \"a\")\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ str │\n╞═════╡\n│ a   │\n│ b   │\n└─────┘\n&gt;&gt;&gt; final_df = pl.DataFrame({\"a\": [\"a\"]})\n&gt;&gt;&gt; final_df.pipe(plg.maintains_relationships, initial_df, \"a\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Some values were removed from col 'a', for ex: ('b',)",
    "crumbs": [
      "Check functions",
      "maintains_relationships"
    ]
  },
  {
    "objectID": "reference/maintains_relationships.html#parameters",
    "href": "reference/maintains_relationships.html#parameters",
    "title": "maintains_relationships",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nDataframe after transformation\nrequired\n\n\nother_df\npolars.polars.DataFrame\nDistant dataframe usually the one before transformation\nrequired\n\n\ncolumn\nstr\nColumn to check for keys/ids\nrequired",
    "crumbs": [
      "Check functions",
      "maintains_relationships"
    ]
  },
  {
    "objectID": "reference/maintains_relationships.html#returns",
    "href": "reference/maintains_relationships.html#returns",
    "title": "maintains_relationships",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "maintains_relationships"
    ]
  },
  {
    "objectID": "reference/maintains_relationships.html#examples",
    "href": "reference/maintains_relationships.html#examples",
    "title": "maintains_relationships",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; initial_df = pl.DataFrame({\"a\": [\"a\", \"b\"]})\n&gt;&gt;&gt; final_df = pl.DataFrame({\"a\": [\"a\", \"b\"]})\n&gt;&gt;&gt; final_df.pipe(plg.maintains_relationships, initial_df, \"a\")\nshape: (2, 1)\n┌─────┐\n│ a   │\n│ --- │\n│ str │\n╞═════╡\n│ a   │\n│ b   │\n└─────┘\n&gt;&gt;&gt; final_df = pl.DataFrame({\"a\": [\"a\"]})\n&gt;&gt;&gt; final_df.pipe(plg.maintains_relationships, initial_df, \"a\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nError with the DataFrame passed to the check function:\n--&gt;Some values were removed from col 'a', for ex: ('b',)",
    "crumbs": [
      "Check functions",
      "maintains_relationships"
    ]
  },
  {
    "objectID": "reference/unique_combination_of_columns.html",
    "href": "reference/unique_combination_of_columns.html",
    "title": "unique_combination_of_columns",
    "section": "",
    "text": "checks.unique_combination_of_columns(data, columns=None)\nEnsure that the selected column have a unique combination per row. This function is particularly helpful to establish the granularity of a dataframe, i.e. this is a row oriented check.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\ndescription\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for row unicity. By default, all columns are checked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [\"a\", \"a\"], \"b\": [1, 2]})\n&gt;&gt;&gt; df.pipe(plg.unique_combination_of_columns, [\"a\", \"b\"])\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ str ┆ i64 │\n╞═════╪═════╡\n│ a   ┆ 1   │\n│ a   ┆ 2   │\n└─────┴─────┘\n&gt;&gt;&gt; bad = pl.DataFrame({\"a\": [\"X\", \"X\"]})\n&gt;&gt;&gt; bad.pipe(plg.unique_combination_of_columns, \"a\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 2)\n┌─────┬─────┐\n│ a   ┆ len │\n│ --- ┆ --- │\n│ str ┆ u32 │\n╞═════╪═════╡\n│ X   ┆ 2   │\n└─────┴─────┘\nError with the DataFrame passed to the check function:\n--&gt;Some combinations of columns are not unique. See above, selected: col(\"a\")",
    "crumbs": [
      "Check functions",
      "unique_combination_of_columns"
    ]
  },
  {
    "objectID": "reference/unique_combination_of_columns.html#parameters",
    "href": "reference/unique_combination_of_columns.html#parameters",
    "title": "unique_combination_of_columns",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\ndescription\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for row unicity. By default, all columns are checked.\nNone",
    "crumbs": [
      "Check functions",
      "unique_combination_of_columns"
    ]
  },
  {
    "objectID": "reference/unique_combination_of_columns.html#returns",
    "href": "reference/unique_combination_of_columns.html#returns",
    "title": "unique_combination_of_columns",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "unique_combination_of_columns"
    ]
  },
  {
    "objectID": "reference/unique_combination_of_columns.html#examples",
    "href": "reference/unique_combination_of_columns.html#examples",
    "title": "unique_combination_of_columns",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame({\"a\": [\"a\", \"a\"], \"b\": [1, 2]})\n&gt;&gt;&gt; df.pipe(plg.unique_combination_of_columns, [\"a\", \"b\"])\nshape: (2, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ str ┆ i64 │\n╞═════╪═════╡\n│ a   ┆ 1   │\n│ a   ┆ 2   │\n└─────┴─────┘\n&gt;&gt;&gt; bad = pl.DataFrame({\"a\": [\"X\", \"X\"]})\n&gt;&gt;&gt; bad.pipe(plg.unique_combination_of_columns, \"a\")\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (1, 2)\n┌─────┬─────┐\n│ a   ┆ len │\n│ --- ┆ --- │\n│ str ┆ u32 │\n╞═════╪═════╡\n│ X   ┆ 2   │\n└─────┴─────┘\nError with the DataFrame passed to the check function:\n--&gt;Some combinations of columns are not unique. See above, selected: col(\"a\")",
    "crumbs": [
      "Check functions",
      "unique_combination_of_columns"
    ]
  },
  {
    "objectID": "reference/PolarsColumnBounds.html",
    "href": "reference/PolarsColumnBounds.html",
    "title": "PolarsColumnBounds",
    "section": "",
    "text": "PolarsColumnBounds\nchecks.PolarsColumnBounds"
  },
  {
    "objectID": "reference/PolarsAssertError.html",
    "href": "reference/PolarsAssertError.html",
    "title": "PolarsAssertError",
    "section": "",
    "text": "PolarsAssertError\nchecks.PolarsAssertError(self, df=pl.DataFrame(), supp_message='')",
    "crumbs": [
      "Exceptions",
      "PolarsAssertError"
    ]
  },
  {
    "objectID": "reference/not_accepted_values.html",
    "href": "reference/not_accepted_values.html",
    "title": "not_accepted_values",
    "section": "",
    "text": "checks.not_accepted_values(data, items)\nRaises error if columns contains values specified in List of forbbiden items\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\n\nrequired\n\n\nitems\ntyping.Dict[str, typing.List]\nA dictionnary where keys are a string compatible with a pl.Expr, to be used with pl.col(). The value for each key is a List of all forbidden values in the dataframe.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]}\n... )\n&gt;&gt;&gt; df.pipe(plg.not_accepted_values, {\"a\": [4, 5]})\nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n│ 3   ┆ c   │\n└─────┴─────┘\n&gt;&gt;&gt; df.pipe(plg.not_accepted_values, {\"b\": [\"a\", \"b\"]})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (2, 1)\n┌─────┐\n│ b   │\n│ --- │\n│ str │\n╞═════╡\n│ a   │\n│ b   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;This DataFrame contains values marked as forbidden",
    "crumbs": [
      "Check functions",
      "not_accepted_values"
    ]
  },
  {
    "objectID": "reference/not_accepted_values.html#parameters",
    "href": "reference/not_accepted_values.html#parameters",
    "title": "not_accepted_values",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\n\nrequired\n\n\nitems\ntyping.Dict[str, typing.List]\nA dictionnary where keys are a string compatible with a pl.Expr, to be used with pl.col(). The value for each key is a List of all forbidden values in the dataframe.\nrequired",
    "crumbs": [
      "Check functions",
      "not_accepted_values"
    ]
  },
  {
    "objectID": "reference/not_accepted_values.html#returns",
    "href": "reference/not_accepted_values.html#returns",
    "title": "not_accepted_values",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "not_accepted_values"
    ]
  },
  {
    "objectID": "reference/not_accepted_values.html#examples",
    "href": "reference/not_accepted_values.html#examples",
    "title": "not_accepted_values",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pelage as plg\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\"a\": [1, 2, 3], \"b\": [\"a\", \"b\", \"c\"]}\n... )\n&gt;&gt;&gt; df.pipe(plg.not_accepted_values, {\"a\": [4, 5]})\nshape: (3, 2)\n┌─────┬─────┐\n│ a   ┆ b   │\n│ --- ┆ --- │\n│ i64 ┆ str │\n╞═════╪═════╡\n│ 1   ┆ a   │\n│ 2   ┆ b   │\n│ 3   ┆ c   │\n└─────┴─────┘\n&gt;&gt;&gt; df.pipe(plg.not_accepted_values, {\"b\": [\"a\", \"b\"]})\nTraceback (most recent call last):\n...\npelage.checks.PolarsAssertError: Details\nshape: (2, 1)\n┌─────┐\n│ b   │\n│ --- │\n│ str │\n╞═════╡\n│ a   │\n│ b   │\n└─────┘\nError with the DataFrame passed to the check function:\n--&gt;This DataFrame contains values marked as forbidden",
    "crumbs": [
      "Check functions",
      "not_accepted_values"
    ]
  },
  {
    "objectID": "reference/has_no_nulls.html",
    "href": "reference/has_no_nulls.html",
    "title": "has_no_nulls",
    "section": "",
    "text": "checks.has_no_nulls(data, columns=None)\nCheck if a DataFrame has any null (missing) values.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe input DataFrame to check for null values.\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for null value check. By default, all columns are checked.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes\n\n\n\n\n\n\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pelage import checks\n&gt;&gt;&gt; df = pl.DataFrame({\n...     \"A\": [1, 2],\n...     \"B\": [None, 5]\n... })\n&gt;&gt;&gt; df\nshape: (2, 2)\n┌─────┬──────┐\n│ A   ┆ B    │\n│ --- ┆ ---  │\n│ i64 ┆ i64  │\n╞═════╪══════╡\n│ 1   ┆ null │\n│ 2   ┆ 5    │\n└─────┴──────┘\n&gt;&gt;&gt; checks.has_no_nulls(df)\nTraceback (most recent call last):\n    ...\npelage.checks.PolarsAssertError: Details\nshape: (1, 2)\n┌────────┬────────────┐\n│ column ┆ null_count │\n│ ---    ┆ ---        │\n│ str    ┆ u32        │\n╞════════╪════════════╡\n│ B      ┆ 1          │\n└────────┴────────────┘\nError with the DataFrame passed to the check function:\n--&gt;There were unexpected nulls in the columns above",
    "crumbs": [
      "Check functions",
      "has_no_nulls"
    ]
  },
  {
    "objectID": "reference/has_no_nulls.html#parameters",
    "href": "reference/has_no_nulls.html#parameters",
    "title": "has_no_nulls",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata\npolars.polars.DataFrame\nThe input DataFrame to check for null values.\nrequired\n\n\ncolumns\ntyping.Optional[pelage.checks.PolarsColumnType]\nColumns to consider for null value check. By default, all columns are checked.\nNone",
    "crumbs": [
      "Check functions",
      "has_no_nulls"
    ]
  },
  {
    "objectID": "reference/has_no_nulls.html#returns",
    "href": "reference/has_no_nulls.html#returns",
    "title": "has_no_nulls",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npolars.polars.DataFrame\nThe original polars DataFrame when the check passes",
    "crumbs": [
      "Check functions",
      "has_no_nulls"
    ]
  },
  {
    "objectID": "reference/has_no_nulls.html#examples",
    "href": "reference/has_no_nulls.html#examples",
    "title": "has_no_nulls",
    "section": "",
    "text": "&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pelage import checks\n&gt;&gt;&gt; df = pl.DataFrame({\n...     \"A\": [1, 2],\n...     \"B\": [None, 5]\n... })\n&gt;&gt;&gt; df\nshape: (2, 2)\n┌─────┬──────┐\n│ A   ┆ B    │\n│ --- ┆ ---  │\n│ i64 ┆ i64  │\n╞═════╪══════╡\n│ 1   ┆ null │\n│ 2   ┆ 5    │\n└─────┴──────┘\n&gt;&gt;&gt; checks.has_no_nulls(df)\nTraceback (most recent call last):\n    ...\npelage.checks.PolarsAssertError: Details\nshape: (1, 2)\n┌────────┬────────────┐\n│ column ┆ null_count │\n│ ---    ┆ ---        │\n│ str    ┆ u32        │\n╞════════╪════════════╡\n│ B      ┆ 1          │\n└────────┴────────────┘\nError with the DataFrame passed to the check function:\n--&gt;There were unexpected nulls in the columns above",
    "crumbs": [
      "Check functions",
      "has_no_nulls"
    ]
  }
]
